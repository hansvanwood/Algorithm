package 模拟评测.第五套试题;

/**
 * 删数问题（贪心算法）
 * <p>
 * 问题描述
 * 对于一个整数，一次删除数位是指将其中的某个数位删除，其他数位按原来的顺序组成的数。
 * 例如，32768执行一次删除数位可能得到2768、3768、3268、3278、3276。
 * 请问，对于整数54971263591276349213，执行10次删除数位后，得到的最小数是多少？
 * <p>
 * 解题策略
 * 贪心选择性质:在当前看来最好的选择
 * 对于数字而言，越往左侧的数字越小，整体就会越小。这里就找到了贪心的条件。
 * 例:对于数字54971263591276349213，删掉5，变为删掉一个数字之后最小的数。
 * 为什么要删掉5，而不是其他的呢?
 * 因为要结合贪心的条件:越往左侧的数字越小，整体的数值就会越小。5比后面的数字大，这个时候删除5，后面的数字就会顶上来，代替8的位置，
 * 这个时候是符合贪心条件的，因为它让这个位置的数字变小了。如果这个位置的5不被替换掉，后面不管是什么数字，只要相同的长度，永远比这个位置是5的数值大。
 * 过程(以删掉四个数字为例):54971263591276349213->4971263591276349213->471263591276349213->41263591276349213->1263591276349213
 *
 * @author : bugu
 * @date : 2024-03-23 14:45
 */
public class T04_number {

    public static void main(String[] args) {
        //要注意规避第二位数为0的可能，第二个数为0，但是又不能一次性直接删两位数
        //4087 (删一位)->087(答案错误)
        String st = "54971263591276349213";
        int k = 10;
        while (k != 0) {

            int target = -1;
            // 找第一个山峰
            for (int i = 0; i + 1 < st.length(); ++i) {
                if (st.charAt(i + 1) < st.charAt(i)) {
                    target = i;
                    break;
                }
            }
            if (target == -1)
                target = st.length() - 1;
            st = st.substring(0, target) + st.substring(target + 1, st.length());

            k--;
        }

        if (st.charAt(0) == '0' && st.length() > 1) {
            int kk = 0;
            while (kk < st.length() && st.charAt(kk) == '0') kk++;
            if (kk == st.length()) kk--;
            st = st.substring(kk, st.length() - kk);
        }
        System.out.println(st);

    }
}